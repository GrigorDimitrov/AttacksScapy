#!/usr/bin/python
from scapy.all import *

# Interacts with a client by going through the three-way handshake.
# Shuts down the connection immediately after the connection has been established.
# Akaljed Dec 2010, http://www.akaljed.wordpress.com
# run "sudo iptables -A OUTPUT -p tcp --tcp-flags RST RST --sport 80 -j DROP"
# sr() can be used instead of sniff(). This could fix the retransmission.

def ek():
    # Wait for client to connect.
    a=sniff(iface="eth0",count=1,filter="tcp and host 192.168.204.129 and port 80")
    
    # some variables for later use.
    ValueOfPort=a[0].sport
    SeqNr=a[0].seq
    AckNr=a[0].seq+1
    
    # Generating the IP layer:
    ip=IP(src="192.168.204.135", dst="192.168.204.129")
    # Generating TCP layer:
    TCP_SYNACK=TCP(sport=80, dport=ValueOfPort, flags="SA", seq=SeqNr, ack=AckNr, options=[('MSS', 1460)])
    
    #send SYNACK to remote host AND receive ACK.
    ANSWER=sr1(ip/TCP_SYNACK)
    
    # Capture next TCP packets with dport 80. (contains http GET request)
    GEThttp = sniff(iface="eth0",filter="tcp and host 192.168.204.129 and port 80",count=1,prn=lambda x:x.sprintf("{IP:%IP.src%: %TCP.dport%}"))
   
    # Calculating ACK (i.e. segment length)
    ip_total_len = GEThttp[0].getlayer(IP).len
    ip_header_len = GEThttp[0].getlayer(IP).ihl * 32 / 8
    tcp_header_len = GEThttp[0].getlayer(TCP).dataofs * 32 / 8
    tcp_seg_len = ip_total_len - ip_header_len - tcp_header_len
    AckNr=AckNr+int(tcp_seg_len)
    SeqNr=a[0].seq+1
   
    # Print the GET request
    # (Sanity check: size of data should be greater than 1.)
    if (GEThttp[0] is not None): 
      print(GEThttp[0].show())
    
    # Generate TCP data for GET request ACK
    tcp=TCP(sport=80, dport=ValueOfPort, flags="A", seq=SeqNr, ack=AckNr, options=[('Len',0)])
    
    # Construct whole network packet, send it and fetch the returning ack.
    send(ip/tcp)
    
    # Generate custom http file content.
    html1 = 'HTTP/1.1 200 OK\r\nDate: Mon, 10 Dec 2012 06:33:53 GMT\r\nServer: Apache/2.2.22 (Ubuntu)\r\nLast-Modified: Mon, 10 Dec 2012 06:18:23 GMT\r\nETag: "1062407-6-4d079884fb4f2"\r\nAccept-Ranges: bytes\r\nContent-Length: 52\r\nVary: Accept-Encoding\r\nKeep-Alive: timeout=5, max=100\r\nConnection: Keep-Alive\r\nContent-Type: text/html\r\n\r\n=[0x9,0x9,0x2f,0x2a,0x2a,0xa,0x9,0x9,0x20,0x2a,0x20,'
    
    # Generate TCP data
    data1=TCP(sport=80, dport=ValueOfPort, flags="PA", seq=SeqNr, ack=AckNr)
    
    # Construct whole network packet, send it and fetch the returning ack.
    ackdata1=sr1(ip/data1/html1)
    
    # Capture next TCP packets with dport 80. (contains FIN/ACK)
    FIN_ACK = sniff(iface="eth0",filter="tcp and host 192.168.204.129 and port 80",count=1,prn=lambda x:x.sprintf("{IP:%IP.src%: %TCP.dport%}"))
    
    # Store new sequence number.
    SeqNr=FIN_ACK[0].ack
    AckNr=FIN_ACK[0].seq+1
    
    ## Generate ACK packet
    ack_fin=TCP(sport=80, dport=ValueOfPort, flags="A", seq=SeqNr, ack=AckNr)
    send(ip/ack_fin)
    
    ## Generate FIN PSH ACK
    fin_psh_ack = TCP(sport=80, dport=ValueOfPort, flags="FPA", seq=SeqNr, ack=AckNr)
    send(ip/fin_psh_ack)
    
    # The End
